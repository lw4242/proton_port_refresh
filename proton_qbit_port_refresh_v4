# This script kills qbittorrent, ProtonVPN and all its associated components, then restarts everything and copies the port number into qbittorrent's config file
# Credit to axel-devs for original script. This update fixes problems occurring with the new v4 ProtonVPN client

import os
import re
import time
import psutil
import glob
import subprocess

# ------------------- CONFIG -------------------
VPN_EXE = r"C:\Program Files\Proton\VPN\ProtonVPN.Launcher.exe"
QBIT_EXE = r"C:\Program Files\qBittorrent\qbittorrent.exe"
QBIT_CONFIG = r"C:\Users\Plex\AppData\Roaming\qBittorrent\qBittorrent.ini"
LOG_DIR = r"C:\Users\Plex\AppData\Local\Proton\Proton VPN\Logs"

PROCESS_ACTIONS = {
    "openvpn.exe": "kill",
    "qbittorrent.exe": "terminate",
    "ProtonVPN.Client.exe": "kill",
    "ProtonVPNService.exe": "kill",
    "ProtonVPN.WireGuardService.exe": "kill"
}
PORT_PATTERN = r"Port pair (\d{1,5})"
QBIT_PORT_PATTERN = r"(Advanced\\trackerPort=|Session\\Port=)\d+"

# ------------------- FUNCTIONS -------------------

def terminate_conflicting_processes():
    print("Checking and terminating conflicting programs...")
    found = False
    for proc in psutil.process_iter(['name']):
        try:
            name = proc.info['name']
            if name in PROCESS_ACTIONS:
                getattr(proc, PROCESS_ACTIONS[name])()
                found = True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            continue
    if found:
        print("Processes terminated. Waiting for clean exit...")
        time.sleep(3)
    else:
        print("No conflicting processes found.")
        time.sleep(1)
    print(".")

def start_protonvpn():
    print("Starting ProtonVPN...")
    os.startfile(VPN_EXE)
    print(".")

def is_vpn_connected():
    for name, _ in psutil.net_if_addrs().items():
        if 'ProtonVPN' in name or 'tun' in name.lower() or 'tap' in name.lower():
            stats = psutil.net_if_stats().get(name)
            if stats and stats.isup:
                return True
    return False

def wait_for_vpn_connection():
    print("Waiting for ProtonVPN to connect...")
    while not is_vpn_connected():
        print("Still waiting...")
        time.sleep(5)
    print("VPN connected.")
    print(".")

def get_latest_log_file():
    logs = glob.glob(os.path.join(LOG_DIR, "client-logs*"))
    return max(logs, key=os.path.getmtime) if logs else None

def wait_for_port_in_log(log_file):
    print(f"Watching log file: {log_file}")
    last_size = os.path.getsize(log_file)
    print("Waiting for Port pair to appear in the log...")
    while True:
        time.sleep(2)
        new_size = os.path.getsize(log_file)
        if new_size > last_size:
            with open(log_file, "r", encoding="utf-8", errors="ignore") as f:
                f.seek(last_size)
                new_data = f.read()
                match = re.search(PORT_PATTERN, new_data)
                if match:
                    port = match.group(1)
                    print(f"Found port number: {port}")
                    print(".")
                    return port
            last_size = new_size

def update_qbittorrent_port(port):
    print("Updating qBittorrent config...")
    with open(QBIT_CONFIG, "r") as f:
        config = f.read()
    config = re.sub(QBIT_PORT_PATTERN, rf"\1{port}", config)
    with open(QBIT_CONFIG, "w") as f:
        f.write(config)
    print("Port updated.")

def launch_qbittorrent():
    print("Starting qBittorrent...")
    os.startfile(QBIT_EXE)
    print(".")
    print("Done.")
    time.sleep(5)

# ------------------- MAIN -------------------

def main():
    terminate_conflicting_processes()
    start_protonvpn()
    wait_for_vpn_connection()

    log_file = get_latest_log_file()
    if not log_file:
        print("No log file found. Exiting.")
        return

    port = wait_for_port_in_log(log_file)
    if port:
        update_qbittorrent_port(port)
        launch_qbittorrent()

if __name__ == "__main__":
    main()
